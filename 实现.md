## 实现

* 尽量将变量的声明延后，到非得使用该变量的前一刻，这样可以避免构造和析构非必要对象，还可以避免无意义的default构造行为（**尽量延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率**）
* **27** 尽量少做转型动作
  * `const_cast`通常被用来将对象的常量性转除。
  * `dynamic_cast`主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承提醒中的某个类型。
  * `reinterpret_cast` 意图执行低级转型，实际动作可能取决于编译器，这也就表示他不可移植。
  * `static_cast`用来强迫隐式转换，例如将`non-const`对象转为`const`对象。
* **31**
  * 支持”编译依存性最小化“的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes 和 Interface classes。
  * 程序库头文件应该以”完全且仅有声明式“ 的形式存在。这种做法不论是否涉及`templates`都适用。
* 继承与遮掩
* 减少编译依存度的方法
* `virtual`函数的外覆器
* `virtual`函数是动态绑定，而缺省参数值却是静态绑定。（你可能会在"调用一个定义于derived class 内的 `virtual` 函数的同时，却使用 `base class` 为它所指定的缺省参数值"）
* 39？
* 40？
* 显式接口和隐式接口
* 嵌套从属类型名称以`typename`为前导。
* 43？template 中指涉的成员名称是否必须存在，如果在特化类型中不存在该如何处理。
* 44？template 的代码膨胀的解决方法：在针对会产生代码膨胀的参数时，可以利用函数参数或class成员变量替换template 参数。
* 隐式类型转换的实现方法、有序类型转换的实现方法。
* 45？1/2
* 46？ template实参推导
* 47?  类型相关信息在编译器可用，以templates和"templates特化" 完成实现
* 48? `Template metaprogramming`(TMP,模板元编程)可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。
* 52？当写了一个 placement operator new 请一定要写出一个`placement operator delete`。如果没有这样做，你的陈故乡可能会发生隐微而时断时续的内存泄漏。对应的三种new和delete类型的声明方法和相应的注意事项。

## 结论

1. 任何情况下都不该重新定义一个进程而来的`non-virtual`函数
2. 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而`virtual`函数——你唯一应该复写的东西——却是动态绑定。
3. 复合的意义和`public`继承完全不同。
4. 如果你声明`member templates`用于“泛化copy构造”或”泛化assignment操作“，你还是需要声明正常的copy构造函数和copy assignment操作符。
5. 整合重载奇数（`overloading`）后， traits classes 有可能在编译器对类型执行if...else测试
6. 严肃对待编译器发出的警告信息。不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。

