## 函数  

* 返回类型为void的函数，可以返回另一个返回类型同样是void的函数的调用结果
* 在含有`return`语句的循环后需要提供`return`语句，如果没有在运行时可能会出现问题
* 返回类型不是`void`的函数必须返回一个值，有一个例外情况:允许主函数`main`没有返回值就可结束（如果程序控制执行到主函数`main`的最后一个语句还未返回，那么编译器会因是的插入返回0的语句）
* temporary -> temporary object  临时对象
* 千万不要返回局部对象的引用或指针
* 主函数`main`不能调用自身

---

### 函数 ###  

1. 函数声明有函数返回类型、函数名和形参列表组成。这三个元素被称为函数原型，函数原型描述了函数的接口。
   * 形参列表必须包括形参类型，但是不必对形参命名。
2. 默认实参 排列形参
   * 在一个文件中只能为一个形参指定默认实参一次（既可以在函数声明也可以在函数定义中指定默认实参，但两者的应用范围不同	）
3. 内联函数应该在头文件中定义，在头文件中加入或修改内联函数时，使用了该头文件的所有源文件都必须重新编译。
4. `const`对象、指向`const`对象的指针或引用只能用于调用其`const`成员函数，如果尝试用它们来调用非`const`成员函数，则是错误的。
5. 要去别地址、地址空间、空间中存储的值的区别，以指针作为形参，指针本身是`const`它指代指针中存放的目标地址空间的地址值不可变，但这是无意义的，因为作为实参传入的指针，在函数中是一个临时变量，是在函数调用时，通过复制传入实参的值（目标地址）赋给临时变量，这个临时变量是否能改变，并不具有实现函数重载的条件(区分函数)。

---

## 标准IO库 

1. 输出时应多使用`endl `而非'\n'。使用`endl`则不必担心程序崩溃时输出是否悬而未决。
2. 交互式系统通常应确保他们的输入和输出流是绑在一起的。这样做意味着可以保证任何输出，包括给用户的提示，都在试图读之前输出。
3. 如果程序员需要重用文件流读写多个文件，必须在读另一个文件按之前调用clear清除该流的状态。

---

## 迭代器

1. 在使用迭代器编写程序时，必须留意哪些操作会是迭代器失效。使用无效迭代器将会导致严重的运行时错误。
2. 容器元素都是副本
3. vector 任何`insert` 或 `push` 操作都可能导致迭代器失效。当编写循环将元素插入到`vector`或`deque`容器中时，程序必须确保迭代器在每次循环后都得到更新。
4. 不要存储end操作返回会的迭代器。添加或删除`deque`或`Vector`容器内的元素都会导致存储的迭代器失效。
5. 使用越界下标，或调用空容器的front或back函数，都会导致程序出现严重的错误。
6. 对于键类型，唯一的约束就是必须支持 < 操作符，至于是否支持其他的关系或相等运算则不做要求。
7. 在处理算法时，最好将关联容器上的迭代器视为支持自减运算的输入迭代器，而不是完整的双向迭代器。
8. 关联容器的键是const对象。
9. 向算法传递无效的迭代器类别所引起的错误，无法保证会在编译时被捕获到。

## 类  

1. 简单来说，类就是定义了一个新的类型和一个新的作用域。
2. 类背后蕴涵的基本思想是数据抽象和封装。
3. 不完全类型只能以有限方式使用。不能定义该类型的对象。不安全类型只能用于定义指向该类型的指针及引用，或者用于声明使用该类型作为形参类型或返回类型的函数。
4. 当构造函数被声明为`explicit`时，编译器将不使用它作为转换操作符。
5. 为了防止复制，类必须显式声明其复制构造函数为`private`。防止类的友元和成员仍可以进行复制，需要将复制构造函数只是声明但不对其定义。代码中进行了上述的防止复制的处理时，用户代码中的复制尝试将在编译时标记为错误，而成员函数和友元中的复制尝试将在链接时导致错误。
6. 复制和赋值常在一起使用，需要其中一个，大概率也需要另一个。
7. 使用带有指针成员类时要十分小心，需要充分熟悉与此相关的编程技术。
8. 既定义了算数操作符又定义了相关复合赋值操作符的类，一般应使用复合赋值实现算术操作符。
9. 管理容器以及某些算法，使用默认`<`操作符。一般而言，关系操作符，诸如相等操作符，应定义为非成员函数。
10. 赋值操作符可以重载。无论形参为何种类型，赋值操作符必须定义为成员函数，这一点与复合赋值操作符有所不同。赋值操作符与复合赋值操作符应返回左操作数的引用。
11. 下标操作符必须定义为类成员函数。一般需要定义两个版本:一个为非`const`成员并返回引用，另一个为`const`成员并返回`const`引用。
    1. 默认构造函数
    2. 复制构造函数
    3. 析构函数
    4. 赋值操作符重载
    5. 复合赋值操作符
    6. 算数运算符
    7. 箭头操作符
    8. 下标操作符
    9. 解引用操作符
12. 转换函数一般不应该改变被转换的对象。因此，转换操作符通常应定义为`const`成员。
13. 类类型转换之后不能再跟另一个类类型转换。如果需要多个类类型转换，则代码将出错。

#### 显式强制转换消除二义性

* 编译器不会试图区分两个不同的类类型转换。具体而言，既是一个调用需要在类类型转换之后各一个标准转换，而另一个是完全匹配，编译器仍会将该调用标记为错误。

* 利用  

  ```c++
  //test_zh.cpp
  compute(static_cast<int>(si));	//显式将SmallInt类强转为int
  compute(static_cast<double>(si));	//显式将SmallInt类强转为double
  ```

  显式强转消除二义性

####  显式构造函数调用消除二义性

*  对于一个函数，分别重载了两个类作为其形参，其中任意一个构造函数都可以与`manip`的一个版本相匹配，因此函数调用有二义性
* 可以通过显示构造所需类型的值而消除二义性

14. 注意区分重载操作符和重载函数的确定函数调用的区别
    1. 重载函数时，由调用本身确定所考虑的名字的作用域。类类型对性的调用，则只需要考虑该类的成员函数。具有同一名字的成员函数和非成员函数不会相互重载。
    2. 重载操作符时，调用本身不会告诉我们与使用的操作符函数作用域相关的任何事情。因此，成员和非成员版本都必须考虑。
15. 基类通常应将派生类需要重定义的任意函数定义为虚函数。
16. 访问控制权限对于访问控制权的限制在于**不能直接访问**并非**不能访问**
17. 只有成员函数中的代码才应该使用作用域操作符覆盖虚函数机制
18. 虚函数的默认参数遵循调用对象的指针或引用的类别，默认参数为指针或引用类别的虚函数的默认参数。  

### 接口继承与实现继承

* 接口继承为public派生类继承基类的接口，它具有与基类相同的接口。
* 实现继承使用private或protected派生的类不继承基类的接口。派生类在实现中使用被继承类，但继承基类的部分并未成为其接口的一部分。

19. 友元关系不能被继承
20. 派生类到基类的转换。
21. 合成操作对对象的基类部分连同派生部分的成员一起进行复制、赋值或撤销，使用基类的复制构造函数、赋值操作符或析构函数对积累部分进行复制、赋值或撤销。***※***
22. 具有指针成员的类一般需要定义自己的复制控制来管理这些成员。
23. 虚析构函数，析构函数为虚函数，则通过指针调用时，运行哪个析构函数将因指针所指对象类型的不同而不同。***※***

### 三法则

* 如果类需要析构函数，则类几乎也确实需要其他复制控制成员
* 积累几乎总是需要构造函数，从而可以将析构函数蛇为虚函数
* 如果基类为了将析构函数设为虚函数而据有空析构函数，那类具有析构函数并不表示也需要赋值操作符或复制构造函数

24. ***为何不能定义为虚函数*** 	构造函数是在对象完全构造之前运行的，在构造函数运行的时候，对象的动态类型还不完整
25. 生成和撤销对象的过程是一个菱形。生成从基类构造开始到派生类构造结束，撤销从派生类析构开始到基类析构结束。
26. 如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。即，基类构造只能调用基类定义的虚函数。(抽象类？)
27. 类的组织结构是很难懂的，要多学多看

---

## 泛型编程  

1. 定义：以独立于任何特定类型的方式编写代码。
   	* 面向对象编程中的多态性在运行时应用于存在继承关系的类。我们能够编写使用这些类的代码，忽略基类与派生类之间类型上的差异。
   	* 泛型编程中，我们所编写的类和函数能够多态地用于跨域编译时不相关的类型。一个类或一个函数可以用来操纵多种类型的对象。
2. 在C++中，模板是泛型编程的基础。模板是创建类或函数的蓝图或公式。
3. 模板形参表不能为空。
4. 编辑器将确定用什么类型代替每个类型形参，以及用什么值代替每个非类型形参。推导出实际模板实参后，编辑器使用实参代替相应的模板形参产生并编译该版本的函数。
5. 类型形参的实参的受限转换
   1. 类型转换的限制只适用于类型为模板形参的那些实参
   2. const转换：接受const引用或const指针的函数可以分别用非const对象的引用或指针来调用，无需产生新的实例化。如果函数接受非引用类型，形参类型和实参都忽略const，即，无论传递const或非const对象给接收非引用类型的函数，都使用相同的实例化。
   3. 数组或函数到指针的转换： 如果模板形参不是引用类型，则对数组或函数类型的实参应用常规指针转换。
6. 模板编译模型？？？？
7. 类模板成员函数
   1. 必须以关键字template开头，后接类的模板形参表。
   2. 必须指出它是哪个类的成员
   3. 类名必须包含其模板形参
8. 非类型模板实参必须是编译时常量表达式
9. 当授予对给定模板的所有实例的访问权的时候，在作用域中不需要存在该类模板或函数模板的声明。实质上编译器将友元声明也当作类或函数的声明对待。
10. 想要限制对特定实例化的友元关系时，必须在可以用于友元声明之前声明类或函数；（友元特定实例化时，需要在友元声明之前声明）
11. 当定义非模板函数的时候，对实参应用常规转换；当特化模板的时候，对实参类型不应用转换
12. 类模板特化应该与它所特化的模板定义相同的接口，否则当用户试图使用未定义的成员时会感到奇怪。
13. 成员特化的生命与任何其他函数模板一样，必须以空的模板形参表开头

### 命名空间

1. 未命名的命名空间可以在给定文件中不连续，但不能跨越文件，每个文件都有自己的未命名的命名空间
2. 未命名的命名空间用于声明局部于文件的实体。
3. 未命名的命名空间中定义的名字可直接使用。不能使用作用域操作符来引用未命名的命名空间的成员
4. 未命名的命名空间中定义的名字只在包含该命名空间的文件中可见
5. 未命名的命名空间中定义的名字可以在定义该命名空间所在的作用域中找到。
6. 如果头文件定义了未命名的命名空间，那么，在每个包含该头文件的文件中，该命名空间中的名字将定义不同的局部实体。在所有其他方式中，未命名的命名空间的成员都是普通程序实体。
7. `using`声明会屏蔽外部作用域中的同名实体
8. 一个命名空间可以有许多别名，所有的别名以及原来的命名空间名字都可以互换使用
9. `using`指示注入来自一个命名空间的所有名字，会出现全局命名空间污染问题。
10. `using`声明在已有**同名函数且带有相同形参**的作用域中引入，会出错，否则`using`定义给定名字的另一重载实例，效果是增大候选函数集合。

---

## 二叉树

### 性质

1. 在二叉树的第i层至多有 $ 2^{i-1}$个结点（i $\geqslant$1）

2. 深度为`k`的二叉树至多有$2^k-1$个结点，(k $\geqslant$1) 
   $$
   \sum_{n=1}^k 2^{i-1} = 2^k-1
   $$
   
3. 对任何一颗二叉树T，如果其终端结点树为$n_0$ ，度为2的结点数为$n_2$ ，则$n_0 = n_2 +1$。

4. 具有$n$个结点的完全二叉树的深度为$[log_2 n]+1$  

5. 如果对一棵有$n$个结点的完全二叉树(其深度为$[log_2 n]+1$)的结点按层序编号 

